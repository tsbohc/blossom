#!/usr/bin/env lua
package.preload["memoize"] = package.preload["memoize"] or function(...)
  local memoize = {
    _VERSION     = 'memoize v2.0',
    _DESCRIPTION = 'Memoized functions in Lua',
    _URL         = 'https://github.com/kikito/memoize.lua',
    _LICENSE     = [[
      MIT LICENSE
      Copyright (c) 2018 Enrique García Cota
      Permission is hereby granted, free of charge, to any person obtaining a
      copy of this software and associated documentation files (the
      "Software"), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:
      The above copyright notice and this permission notice shall be included
      in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    ]]
  }
  -- Inspired by http://stackoverflow.com/questions/129877/how-do-i-write-a-generic-memoize-function
  
  -- Lua 5.3 compatibility
  local unpack = unpack or table.unpack
  
  -- private stuff
  
  local function is_callable(f)
    local tf = type(f)
    if tf == 'function' then return true end
    if tf == 'table' then
      local mt = getmetatable(f)
      return type(mt) == 'table' and is_callable(mt.__call)
    end
    return false
  end
  
  local function cache_get(cache, params)
    local node = cache
    for i=1, #params do
      node = node.children and node.children[params[i]]
      if not node then return nil end
    end
    return node.results
  end
  
  local function cache_put(cache, params, results)
    local node = cache
    local param
    for i=1, #params do
      param = params[i]
      node.children = node.children or {}
      node.children[param] = node.children[param] or {}
      node = node.children[param]
    end
    node.results = results
  end
  
  -- public function
  
  function memoize.memoize(f, cache)
    cache = cache or {}
  
    if not is_callable(f) then
      error(string.format(
              "Only functions and callable tables are memoizable. Received %s (a %s)",
               tostring(f), type(f)))
    end
  
    return function (...)
      local params = {...}
  
      local results = cache_get(cache, params)
      if not results then
        results = { f(...) }
        cache_put(cache, params, results)
      end
  
      return unpack(results)
    end
  end
  
  setmetatable(memoize, { __call = function(_, ...) return memoize.memoize(...) end })
  
  return memoize
end
package.preload["inspect"] = package.preload["inspect"] or function(...)
  local inspect ={
    _VERSION = 'inspect.lua 3.1.0',
    _URL     = 'http://github.com/kikito/inspect.lua',
    _DESCRIPTION = 'human-readable representations of tables',
    _LICENSE = [[
      MIT LICENSE
      Copyright (c) 2013 Enrique García Cota
      Permission is hereby granted, free of charge, to any person obtaining a
      copy of this software and associated documentation files (the
      "Software"), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:
      The above copyright notice and this permission notice shall be included
      in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    ]]
  }
  
  local tostring = tostring
  
  inspect.KEY       = setmetatable({}, {__tostring = function() return 'inspect.KEY' end})
  inspect.METATABLE = setmetatable({}, {__tostring = function() return 'inspect.METATABLE' end})
  
  local function rawpairs(t)
    return next, t, nil
  end
  
  -- Apostrophizes the string if it has quotes, but not aphostrophes
  -- Otherwise, it returns a regular quoted string
  local function smartQuote(str)
    if str:match('"') and not str:match("'") then
      return "'" .. str .. "'"
    end
    return '"' .. str:gsub('"', '\\"') .. '"'
  end
  
  -- \a => '\\a', \0 => '\\0', 31 => '\31'
  local shortControlCharEscapes = {
    ["\a"] = "\\a",  ["\b"] = "\\b", ["\f"] = "\\f", ["\n"] = "\\n",
    ["\r"] = "\\r",  ["\t"] = "\\t", ["\v"] = "\\v"
  }
  local longControlCharEscapes = {} -- \a => nil, \0 => \000, 31 => \031
  for i=0, 31 do
    local ch = string.char(i)
    if not shortControlCharEscapes[ch] then
      shortControlCharEscapes[ch] = "\\"..i
      longControlCharEscapes[ch]  = string.format("\\%03d", i)
    end
  end
  
  local function escape(str)
    return (str:gsub("\\", "\\\\")
               :gsub("(%c)%f[0-9]", longControlCharEscapes)
               :gsub("%c", shortControlCharEscapes))
  end
  
  local function isIdentifier(str)
    return type(str) == 'string' and str:match( "^[_%a][_%a%d]*$" )
  end
  
  local function isSequenceKey(k, sequenceLength)
    return type(k) == 'number'
       and 1 <= k
       and k <= sequenceLength
       and math.floor(k) == k
  end
  
  local defaultTypeOrders = {
    ['number']   = 1, ['boolean']  = 2, ['string'] = 3, ['table'] = 4,
    ['function'] = 5, ['userdata'] = 6, ['thread'] = 7
  }
  
  local function sortKeys(a, b)
    local ta, tb = type(a), type(b)
  
    -- strings and numbers are sorted numerically/alphabetically
    if ta == tb and (ta == 'string' or ta == 'number') then return a < b end
  
    local dta, dtb = defaultTypeOrders[ta], defaultTypeOrders[tb]
    -- Two default types are compared according to the defaultTypeOrders table
    if dta and dtb then return defaultTypeOrders[ta] < defaultTypeOrders[tb]
    elseif dta     then return true  -- default types before custom ones
    elseif dtb     then return false -- custom types after default ones
    end
  
    -- custom types are sorted out alphabetically
    return ta < tb
  end
  
  -- For implementation reasons, the behavior of rawlen & # is "undefined" when
  -- tables aren't pure sequences. So we implement our own # operator.
  local function getSequenceLength(t)
    local len = 1
    local v = rawget(t,len)
    while v ~= nil do
      len = len + 1
      v = rawget(t,len)
    end
    return len - 1
  end
  
  local function getNonSequentialKeys(t)
    local keys, keysLength = {}, 0
    local sequenceLength = getSequenceLength(t)
    for k,_ in rawpairs(t) do
      if not isSequenceKey(k, sequenceLength) then
        keysLength = keysLength + 1
        keys[keysLength] = k
      end
    end
    table.sort(keys, sortKeys)
    return keys, keysLength, sequenceLength
  end
  
  local function countTableAppearances(t, tableAppearances)
    tableAppearances = tableAppearances or {}
  
    if type(t) == 'table' then
      if not tableAppearances[t] then
        tableAppearances[t] = 1
        for k,v in rawpairs(t) do
          countTableAppearances(k, tableAppearances)
          countTableAppearances(v, tableAppearances)
        end
        countTableAppearances(getmetatable(t), tableAppearances)
      else
        tableAppearances[t] = tableAppearances[t] + 1
      end
    end
  
    return tableAppearances
  end
  
  local copySequence = function(s)
    local copy, len = {}, #s
    for i=1, len do copy[i] = s[i] end
    return copy, len
  end
  
  local function makePath(path, ...)
    local keys = {...}
    local newPath, len = copySequence(path)
    for i=1, #keys do
      newPath[len + i] = keys[i]
    end
    return newPath
  end
  
  local function processRecursive(process, item, path, visited)
    if item == nil then return nil end
    if visited[item] then return visited[item] end
  
    local processed = process(item, path)
    if type(processed) == 'table' then
      local processedCopy = {}
      visited[item] = processedCopy
      local processedKey
  
      for k,v in rawpairs(processed) do
        processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY), visited)
        if processedKey ~= nil then
          processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey), visited)
        end
      end
  
      local mt  = processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE), visited)
      if type(mt) ~= 'table' then mt = nil end -- ignore not nil/table __metatable field
      setmetatable(processedCopy, mt)
      processed = processedCopy
    end
    return processed
  end
  
  
  
  -------------------------------------------------------------------
  
  local Inspector = {}
  local Inspector_mt = {__index = Inspector}
  
  function Inspector:puts(...)
    local args   = {...}
    local buffer = self.buffer
    local len    = #buffer
    for i=1, #args do
      len = len + 1
      buffer[len] = args[i]
    end
  end
  
  function Inspector:down(f)
    self.level = self.level + 1
    f()
    self.level = self.level - 1
  end
  
  function Inspector:tabify()
    self:puts(self.newline, string.rep(self.indent, self.level))
  end
  
  function Inspector:alreadyVisited(v)
    return self.ids[v] ~= nil
  end
  
  function Inspector:getId(v)
    local id = self.ids[v]
    if not id then
      local tv = type(v)
      id              = (self.maxIds[tv] or 0) + 1
      self.maxIds[tv] = id
      self.ids[v]     = id
    end
    return tostring(id)
  end
  
  function Inspector:putKey(k)
    if isIdentifier(k) then return self:puts(k) end
    self:puts("[")
    self:putValue(k)
    self:puts("]")
  end
  
  function Inspector:putTable(t)
    if t == inspect.KEY or t == inspect.METATABLE then
      self:puts(tostring(t))
    elseif self:alreadyVisited(t) then
      self:puts('<table ', self:getId(t), '>')
    elseif self.level >= self.depth then
      self:puts('{...}')
    else
      if self.tableAppearances[t] > 1 then self:puts('<', self:getId(t), '>') end
  
      local nonSequentialKeys, nonSequentialKeysLength, sequenceLength = getNonSequentialKeys(t)
      local mt                = getmetatable(t)
  
      self:puts('{')
      self:down(function()
        local count = 0
        for i=1, sequenceLength do
          if count > 0 then self:puts(',') end
          self:puts(' ')
          self:putValue(t[i])
          count = count + 1
        end
  
        for i=1, nonSequentialKeysLength do
          local k = nonSequentialKeys[i]
          if count > 0 then self:puts(',') end
          self:tabify()
          self:putKey(k)
          self:puts(' = ')
          self:putValue(t[k])
          count = count + 1
        end
  
        if type(mt) == 'table' then
          if count > 0 then self:puts(',') end
          self:tabify()
          self:puts('<metatable> = ')
          self:putValue(mt)
        end
      end)
  
      if nonSequentialKeysLength > 0 or type(mt) == 'table' then -- result is multi-lined. Justify closing }
        self:tabify()
      elseif sequenceLength > 0 then -- array tables have one extra space before closing }
        self:puts(' ')
      end
  
      self:puts('}')
    end
  end
  
  function Inspector:putValue(v)
    local tv = type(v)
  
    if tv == 'string' then
      self:puts(smartQuote(escape(v)))
    elseif tv == 'number' or tv == 'boolean' or tv == 'nil' or
           tv == 'cdata' or tv == 'ctype' then
      self:puts(tostring(v))
    elseif tv == 'table' then
      self:putTable(v)
    else
      self:puts('<', tv, ' ', self:getId(v), '>')
    end
  end
  
  -------------------------------------------------------------------
  
  function inspect.inspect(root, options)
    options       = options or {}
  
    local depth   = options.depth   or math.huge
    local newline = options.newline or '\n'
    local indent  = options.indent  or '  '
    local process = options.process
  
    if process then
      root = processRecursive(process, root, {}, {})
    end
  
    local inspector = setmetatable({
      depth            = depth,
      level            = 0,
      buffer           = {},
      ids              = {},
      maxIds           = {},
      newline          = newline,
      indent           = indent,
      tableAppearances = countTableAppearances(root)
    }, Inspector_mt)
  
    inspector:putValue(root)
  
    return table.concat(inspector.buffer)
  end
  
  setmetatable(inspect, { __call = function(_, ...) return inspect.inspect(...) end })
  
  return inspect
end
local util = nil
package.preload["util"] = package.preload["util"] or function(...)
  local function seq_3f(xs)
    local i = 0
    for _ in pairs(xs) do
      i = (i + 1)
      if (nil == xs[i]) then
        return false
      end
    end
    return true
  end
  local function has_3f(xt, y)
    if seq_3f(xt) then
      for _, v in ipairs(xt) do
        if (v == y) then
          return true
        end
      end
    else
      if (nil ~= xt[y]) then
        return true
      end
    end
    return false
  end
  return {["has?"] = has_3f, ["seq?"] = seq_3f}
end
util = require("util")
inspect = require("inspect")
local _memoize = require("memoize")
local function pretty_print(...)
  return print(inspect(...))
end
local test = {beverage = "coffee", colo = "kohi", dessert = {garnish = "cherry jam", name = "waffles"}, emoji = {happy = "uwu", sad = "-w-"}, ff0000 = "waffle", mood = "happy"}
do
  local function escape(s)
    local function _0_(c)
      return ("%" .. c)
    end
    return s:gsub("[%(%)%.%%%+%-%*%?%[%]%^%$]", _0_)
  end
  local mt = getmetatable("")
  mt["__index"]["escape"] = escape
end
local function lex(x, _3fy, _3fz)
  assert((nil ~= x), string.format("Missing argument %s on %s:%s", "x", "blossom.fnl", 36))
  local pat_l = "{%-"
  local pat_r = "-%}"
  local token_l = "{"
  local token_r = "}"
  if (_3fy == nil) then
    local _0_0 = x
    if (_0_0 == "pat-re") then
      return (pat_l:escape() .. "(.-)" .. pat_r:escape())
    elseif (_0_0 == "token-re") then
      return (token_l:escape() .. "([%w.]+)" .. token_r:escape())
    else
      local _ = _0_0
      return error(("lex contains no such key: " .. x))
    end
  else
    local _0_0 = _3fy
    if (_0_0 == "pat") then
      local _1_
      if _3fz then
        _1_ = pat_l
      else
        _1_ = pat_l:escape()
      end
      local function _3_()
        if _3fz then
          return pat_r
        else
          return pat_r:escape()
        end
      end
      return (_1_ .. x .. _3_())
    elseif (_0_0 == "token") then
      local _1_
      if _3fz then
        _1_ = token_l
      else
        _1_ = token_l:escape()
      end
      local function _3_()
        if _3fz then
          return token_r
        else
          return token_r:escape()
        end
      end
      return (_1_ .. x .. _3_())
    else
      local _ = _0_0
      return error(("lex contains no such key: " .. _3fy))
    end
  end
end
local function slurp(path)
  local file = io.open(path, "r")
  local function close_handlers_0_(ok_0_, ...)
    file:close()
    if ok_0_ then
      return ...
    else
      return error(..., 0)
    end
  end
  local function _0_()
    local s = file:read("*a")
    return s
  end
  return close_handlers_0_(xpcall(_0_, (package.loaded.fennel or debug).traceback))
end
local varset_list = nil
local function _0_()
  local file = assert(io.popen("find varsets -type f", "r"))
  local function close_handlers_0_(ok_0_, ...)
    file:close()
    if ok_0_ then
      return ...
    else
      return error(..., 0)
    end
  end
  local function _1_()
    local xs = {}
    for line in file:lines() do
      local function _3_()
        local _2_0 = line:gsub("varsets/", "")
        return _2_0
      end
      table.insert(xs, _3_())
    end
    return xs
  end
  return close_handlers_0_(xpcall(_1_, (package.loaded.fennel or debug).traceback))
end
varset_list = _memoize(_0_)
local varset = nil
local function _1_(name)
  local file = assert(io.open(("varsets/" .. name), "r"))
  local function close_handlers_0_(ok_0_, ...)
    file:close()
    if ok_0_ then
      return ...
    else
      return error(..., 0)
    end
  end
  local function _2_()
    local comment_re = "%s*!"
    local keyval_re = "(%w+):%s*(%w+)"
    local xt = {}
    for line in file:lines() do
      if not (line:match(comment_re) or (line == "")) then
        local key, val = line:match(keyval_re)
        xt[key] = val
      end
    end
    return xt
  end
  return close_handlers_0_(xpcall(_2_, (package.loaded.fennel or debug).traceback))
end
varset = _memoize(_1_)
varset("arst")
local function get_node(xt, dots)
  local v = xt
  if (type(dots) == "string") then
    for w in dots:gmatch("[%w_]+") do
      if (v == nil) then
      else
        v = v[w]
      end
    end
    if not ((type(v) == "number") or (type(v) == "string")) then
      return error(("token '" .. dots .. "' could not be compiled"))
    else
      return v
    end
  end
end
local function token_value(dots)
  return dots
end
local function tokens_3f(s)
  if s:find(lex("token-re")) then
    return true
  else
    return false
  end
end
local function compile_token(s)
  local key = s:match(lex("token-re"))
  local val = get_node(test, key)
  local _2_0 = s:gsub(lex(key, "token"), val)
  return _2_0
end
local function compile_tokens(s)
  if tokens_3f(s) then
    return compile_tokens(compile_token(s))
  else
    return s
  end
end
local tt = "{%- {{colo.color1 {beverage} and {dessert.name} with {dessert.garnish}! {emoji.{mood}} -%}"
return print(compile_tokens(tt))

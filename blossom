#!/usr/bin/env lua
package.preload["petals"] = package.preload["petals"] or function(...)
  local core = require("core")
  local get = require("get")
  local env = "/home/sean/.garden/etc"
  local petals = {}
  local get_petals = nil
  local function _0_()
    local file = assert(io.popen(("find " .. env .. " -name '*.petal' -type f"), "r"))
    local function close_handlers_0_(ok_0_, ...)
      file:close()
      if ok_0_ then
        return ...
      else
        return error(..., 0)
      end
    end
    local function _1_()
      for line in file:lines() do
        print(line)
      end
      return nil
    end
    return close_handlers_0_(xpcall(_1_, (package.loaded.fennel or debug).traceback))
  end
  get_petals = core.memoize(_0_)
  petals["petals"] = get_petals
  return petals
end
package.preload["fs"] = package.preload["fs"] or function(...)
  local fs = {}
  fs.slurp = function(path)
    local file = assert(io.open(path, "r"))
    local function close_handlers_0_(ok_0_, ...)
      file:close()
      if ok_0_ then
        return ...
      else
        return error(..., 0)
      end
    end
    local function _0_()
      local s = file:read("*a")
      return s
    end
    return close_handlers_0_(xpcall(_0_, (package.loaded.fennel or debug).traceback))
  end
  return fs
end
package.preload["varset"] = package.preload["varset"] or function(...)
  local core = require("core")
  local fs = require("fs")
  local varset = {}
  local varset_list = nil
  local function _0_()
    local file = assert(io.popen("find varsets -type f", "r"))
    local function close_handlers_0_(ok_0_, ...)
      file:close()
      if ok_0_ then
        return ...
      else
        return error(..., 0)
      end
    end
    local function _1_()
      local xs = {}
      for line in file:lines() do
        local function _3_()
          local _2_0 = line:gsub("varsets/", "")
          return _2_0
        end
        table.insert(xs, _3_())
      end
      return xs
    end
    return close_handlers_0_(xpcall(_1_, (package.loaded.fennel or debug).traceback))
  end
  varset_list = core.memoize(_0_)
  local varset_get = nil
  local function _1_(name)
    local file = assert(io.open(("varsets/" .. name), "r"))
    local function close_handlers_0_(ok_0_, ...)
      file:close()
      if ok_0_ then
        return ...
      else
        return error(..., 0)
      end
    end
    local function _2_()
      local comment_re = "%s*!"
      local keyval_re = "(%w+):%s*(%w+)"
      local xt = {}
      for line in file:lines() do
        if not (line:match(comment_re) or (line == "")) then
          local key, val = line:match(keyval_re)
          xt[key] = val
        end
      end
      return xt
    end
    return close_handlers_0_(xpcall(_2_, (package.loaded.fennel or debug).traceback))
  end
  varset_get = core.memoize(_1_)
  varset["list"] = varset_list
  varset["get"] = varset_get
  local function _2_(_, ...)
    return varset.get(...)
  end
  setmetatable(varset, {__call = _2_})
  return varset
end
package.preload["get"] = package.preload["get"] or function(...)
  local core = require("core")
  local varset = require("varset")
  local get = {}
  local function fe(xt, path)
    return xt[path]
  end
  get["from-env"] = function(s)
    return os.getenv(("blossom_" .. s))
  end
  get["from-var"] = function(s)
    local root = s:match("(%w+)%.")
    local path = s:match("%.([%w.]+)")
    if (nil ~= root) then
      if core["has?"](varset.list(), root) then
        return fe(varset(root), path)
      else
        return error(("varset '" .. root .. "' doesn't exist"))
      end
    end
  end
  get.get = function(s)
    local v = (get["from-env"](s) or get["from-var"](s))
    if (v == nil) then
      return error(("value of token '" .. s .. "' could not be found."))
    else
      return v
    end
  end
  local function _0_(_, ...)
    return get.get(...)
  end
  setmetatable(get, {__call = _0_})
  return get
end
package.preload["lexis"] = package.preload["lexis"] or function(...)
  local g = {["pattern-l"] = "{%-", ["pattern-r"] = "-%}", ["token-l"] = "{", ["token-r"] = "}"}
  local lexis = {}
  lexis["pattern-esc"] = function(s)
    return ((g["pattern-l"]):escape() .. s .. (g["pattern-r"]):escape())
  end
  lexis["pattern-lit"] = function(s)
    return (g["pattern-l"]() .. s .. g["pattern-r"]())
  end
  lexis["token-esc"] = function(s)
    return ((g["token-l"]):escape() .. s .. (g["token-r"]):escape())
  end
  lexis["token-lit"] = function(s)
    return (g["token-l"]() .. s .. g["token-r"]())
  end
  lexis["pattern-re"] = lexis["pattern-esc"]("(.-)")
  lexis["token-re"] = lexis["token-esc"]("([%w.]+)")
  return lexis
end
package.preload["tokens"] = package.preload["tokens"] or function(...)
  local core = require("core")
  local lexis = require("lexis")
  local get = require("get")
  local tokens = {}
  local function has_tokens_3f(s)
    if s:find(lexis["token-re"]) then
      return true
    else
      return false
    end
  end
  local function compile_single(s)
    local key = s:match(lexis["token-re"])
    local val = get(key)
    local _0_0 = s:gsub(lexis["token-esc"](key), val)
    return _0_0
  end
  tokens.compile = function(s)
    if has_tokens_3f(s) then
      return tokens.compile(compile_single(s))
    else
      return s
    end
  end
  return tokens
end
local core = nil
package.preload["memoize"] = package.preload["memoize"] or function(...)
  local memoize = {
    _VERSION     = 'memoize v2.0',
    _DESCRIPTION = 'Memoized functions in Lua',
    _URL         = 'https://github.com/kikito/memoize.lua',
    _LICENSE     = [[
      MIT LICENSE
      Copyright (c) 2018 Enrique García Cota
      Permission is hereby granted, free of charge, to any person obtaining a
      copy of this software and associated documentation files (the
      "Software"), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:
      The above copyright notice and this permission notice shall be included
      in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    ]]
  }
  -- Inspired by http://stackoverflow.com/questions/129877/how-do-i-write-a-generic-memoize-function
  
  -- Lua 5.3 compatibility
  local unpack = unpack or table.unpack
  
  -- private stuff
  
  local function is_callable(f)
    local tf = type(f)
    if tf == 'function' then return true end
    if tf == 'table' then
      local mt = getmetatable(f)
      return type(mt) == 'table' and is_callable(mt.__call)
    end
    return false
  end
  
  local function cache_get(cache, params)
    local node = cache
    for i=1, #params do
      node = node.children and node.children[params[i]]
      if not node then return nil end
    end
    return node.results
  end
  
  local function cache_put(cache, params, results)
    local node = cache
    local param
    for i=1, #params do
      param = params[i]
      node.children = node.children or {}
      node.children[param] = node.children[param] or {}
      node = node.children[param]
    end
    node.results = results
  end
  
  -- public function
  
  function memoize.memoize(f, cache)
    cache = cache or {}
  
    if not is_callable(f) then
      error(string.format(
              "Only functions and callable tables are memoizable. Received %s (a %s)",
               tostring(f), type(f)))
    end
  
    return function (...)
      local params = {...}
  
      local results = cache_get(cache, params)
      if not results then
        results = { f(...) }
        cache_put(cache, params, results)
      end
  
      return unpack(results)
    end
  end
  
  setmetatable(memoize, { __call = function(_, ...) return memoize.memoize(...) end })
  
  return memoize
end
package.preload["inspect"] = package.preload["inspect"] or function(...)
  local inspect ={
    _VERSION = 'inspect.lua 3.1.0',
    _URL     = 'http://github.com/kikito/inspect.lua',
    _DESCRIPTION = 'human-readable representations of tables',
    _LICENSE = [[
      MIT LICENSE
      Copyright (c) 2013 Enrique García Cota
      Permission is hereby granted, free of charge, to any person obtaining a
      copy of this software and associated documentation files (the
      "Software"), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:
      The above copyright notice and this permission notice shall be included
      in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    ]]
  }
  
  local tostring = tostring
  
  inspect.KEY       = setmetatable({}, {__tostring = function() return 'inspect.KEY' end})
  inspect.METATABLE = setmetatable({}, {__tostring = function() return 'inspect.METATABLE' end})
  
  local function rawpairs(t)
    return next, t, nil
  end
  
  -- Apostrophizes the string if it has quotes, but not aphostrophes
  -- Otherwise, it returns a regular quoted string
  local function smartQuote(str)
    if str:match('"') and not str:match("'") then
      return "'" .. str .. "'"
    end
    return '"' .. str:gsub('"', '\\"') .. '"'
  end
  
  -- \a => '\\a', \0 => '\\0', 31 => '\31'
  local shortControlCharEscapes = {
    ["\a"] = "\\a",  ["\b"] = "\\b", ["\f"] = "\\f", ["\n"] = "\\n",
    ["\r"] = "\\r",  ["\t"] = "\\t", ["\v"] = "\\v"
  }
  local longControlCharEscapes = {} -- \a => nil, \0 => \000, 31 => \031
  for i=0, 31 do
    local ch = string.char(i)
    if not shortControlCharEscapes[ch] then
      shortControlCharEscapes[ch] = "\\"..i
      longControlCharEscapes[ch]  = string.format("\\%03d", i)
    end
  end
  
  local function escape(str)
    return (str:gsub("\\", "\\\\")
               :gsub("(%c)%f[0-9]", longControlCharEscapes)
               :gsub("%c", shortControlCharEscapes))
  end
  
  local function isIdentifier(str)
    return type(str) == 'string' and str:match( "^[_%a][_%a%d]*$" )
  end
  
  local function isSequenceKey(k, sequenceLength)
    return type(k) == 'number'
       and 1 <= k
       and k <= sequenceLength
       and math.floor(k) == k
  end
  
  local defaultTypeOrders = {
    ['number']   = 1, ['boolean']  = 2, ['string'] = 3, ['table'] = 4,
    ['function'] = 5, ['userdata'] = 6, ['thread'] = 7
  }
  
  local function sortKeys(a, b)
    local ta, tb = type(a), type(b)
  
    -- strings and numbers are sorted numerically/alphabetically
    if ta == tb and (ta == 'string' or ta == 'number') then return a < b end
  
    local dta, dtb = defaultTypeOrders[ta], defaultTypeOrders[tb]
    -- Two default types are compared according to the defaultTypeOrders table
    if dta and dtb then return defaultTypeOrders[ta] < defaultTypeOrders[tb]
    elseif dta     then return true  -- default types before custom ones
    elseif dtb     then return false -- custom types after default ones
    end
  
    -- custom types are sorted out alphabetically
    return ta < tb
  end
  
  -- For implementation reasons, the behavior of rawlen & # is "undefined" when
  -- tables aren't pure sequences. So we implement our own # operator.
  local function getSequenceLength(t)
    local len = 1
    local v = rawget(t,len)
    while v ~= nil do
      len = len + 1
      v = rawget(t,len)
    end
    return len - 1
  end
  
  local function getNonSequentialKeys(t)
    local keys, keysLength = {}, 0
    local sequenceLength = getSequenceLength(t)
    for k,_ in rawpairs(t) do
      if not isSequenceKey(k, sequenceLength) then
        keysLength = keysLength + 1
        keys[keysLength] = k
      end
    end
    table.sort(keys, sortKeys)
    return keys, keysLength, sequenceLength
  end
  
  local function countTableAppearances(t, tableAppearances)
    tableAppearances = tableAppearances or {}
  
    if type(t) == 'table' then
      if not tableAppearances[t] then
        tableAppearances[t] = 1
        for k,v in rawpairs(t) do
          countTableAppearances(k, tableAppearances)
          countTableAppearances(v, tableAppearances)
        end
        countTableAppearances(getmetatable(t), tableAppearances)
      else
        tableAppearances[t] = tableAppearances[t] + 1
      end
    end
  
    return tableAppearances
  end
  
  local copySequence = function(s)
    local copy, len = {}, #s
    for i=1, len do copy[i] = s[i] end
    return copy, len
  end
  
  local function makePath(path, ...)
    local keys = {...}
    local newPath, len = copySequence(path)
    for i=1, #keys do
      newPath[len + i] = keys[i]
    end
    return newPath
  end
  
  local function processRecursive(process, item, path, visited)
    if item == nil then return nil end
    if visited[item] then return visited[item] end
  
    local processed = process(item, path)
    if type(processed) == 'table' then
      local processedCopy = {}
      visited[item] = processedCopy
      local processedKey
  
      for k,v in rawpairs(processed) do
        processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY), visited)
        if processedKey ~= nil then
          processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey), visited)
        end
      end
  
      local mt  = processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE), visited)
      if type(mt) ~= 'table' then mt = nil end -- ignore not nil/table __metatable field
      setmetatable(processedCopy, mt)
      processed = processedCopy
    end
    return processed
  end
  
  
  
  -------------------------------------------------------------------
  
  local Inspector = {}
  local Inspector_mt = {__index = Inspector}
  
  function Inspector:puts(...)
    local args   = {...}
    local buffer = self.buffer
    local len    = #buffer
    for i=1, #args do
      len = len + 1
      buffer[len] = args[i]
    end
  end
  
  function Inspector:down(f)
    self.level = self.level + 1
    f()
    self.level = self.level - 1
  end
  
  function Inspector:tabify()
    self:puts(self.newline, string.rep(self.indent, self.level))
  end
  
  function Inspector:alreadyVisited(v)
    return self.ids[v] ~= nil
  end
  
  function Inspector:getId(v)
    local id = self.ids[v]
    if not id then
      local tv = type(v)
      id              = (self.maxIds[tv] or 0) + 1
      self.maxIds[tv] = id
      self.ids[v]     = id
    end
    return tostring(id)
  end
  
  function Inspector:putKey(k)
    if isIdentifier(k) then return self:puts(k) end
    self:puts("[")
    self:putValue(k)
    self:puts("]")
  end
  
  function Inspector:putTable(t)
    if t == inspect.KEY or t == inspect.METATABLE then
      self:puts(tostring(t))
    elseif self:alreadyVisited(t) then
      self:puts('<table ', self:getId(t), '>')
    elseif self.level >= self.depth then
      self:puts('{...}')
    else
      if self.tableAppearances[t] > 1 then self:puts('<', self:getId(t), '>') end
  
      local nonSequentialKeys, nonSequentialKeysLength, sequenceLength = getNonSequentialKeys(t)
      local mt                = getmetatable(t)
  
      self:puts('{')
      self:down(function()
        local count = 0
        for i=1, sequenceLength do
          if count > 0 then self:puts(',') end
          self:puts(' ')
          self:putValue(t[i])
          count = count + 1
        end
  
        for i=1, nonSequentialKeysLength do
          local k = nonSequentialKeys[i]
          if count > 0 then self:puts(',') end
          self:tabify()
          self:putKey(k)
          self:puts(' = ')
          self:putValue(t[k])
          count = count + 1
        end
  
        if type(mt) == 'table' then
          if count > 0 then self:puts(',') end
          self:tabify()
          self:puts('<metatable> = ')
          self:putValue(mt)
        end
      end)
  
      if nonSequentialKeysLength > 0 or type(mt) == 'table' then -- result is multi-lined. Justify closing }
        self:tabify()
      elseif sequenceLength > 0 then -- array tables have one extra space before closing }
        self:puts(' ')
      end
  
      self:puts('}')
    end
  end
  
  function Inspector:putValue(v)
    local tv = type(v)
  
    if tv == 'string' then
      self:puts(smartQuote(escape(v)))
    elseif tv == 'number' or tv == 'boolean' or tv == 'nil' or
           tv == 'cdata' or tv == 'ctype' then
      self:puts(tostring(v))
    elseif tv == 'table' then
      self:putTable(v)
    else
      self:puts('<', tv, ' ', self:getId(v), '>')
    end
  end
  
  -------------------------------------------------------------------
  
  function inspect.inspect(root, options)
    options       = options or {}
  
    local depth   = options.depth   or math.huge
    local newline = options.newline or '\n'
    local indent  = options.indent  or '  '
    local process = options.process
  
    if process then
      root = processRecursive(process, root, {}, {})
    end
  
    local inspector = setmetatable({
      depth            = depth,
      level            = 0,
      buffer           = {},
      ids              = {},
      maxIds           = {},
      newline          = newline,
      indent           = indent,
      tableAppearances = countTableAppearances(root)
    }, Inspector_mt)
  
    inspector:putValue(root)
  
    return table.concat(inspector.buffer)
  end
  
  setmetatable(inspect, { __call = function(_, ...) return inspect.inspect(...) end })
  
  return inspect
end
package.preload["core"] = package.preload["core"] or function(...)
  do
    local function escape(s)
      local _0_0 = nil
      local function _1_(c)
        return ("%" .. c)
      end
      _0_0 = s:gsub("[%(%)%.%%%+%-%*%?%[%]%^%$]", _1_)
      return _0_0
    end
    local mt = getmetatable("")
    mt["__index"]["escape"] = escape
  end
  local function seq_3f(xs)
    local i = 0
    for _ in pairs(xs) do
      i = (i + 1)
      if (nil == xs[i]) then
        return false
      end
    end
    return true
  end
  local function has_3f(xt, y)
    if seq_3f(xt) then
      for _, v in ipairs(xt) do
        if (v == y) then
          return true
        end
      end
    else
      if (nil ~= xt[y]) then
        return true
      end
    end
    return false
  end
  return {["has?"] = has_3f, ["seq?"] = seq_3f, inspect = require("inspect"), memoize = require("memoize")}
end
core = require("core")
local tokens = require("tokens")
local tt = "{%- {kohi.color2} -%}"
print(tokens.compile(tt))
local petals = require("petals")
return petals.petals()
